# Webcast: Problem Solving with Loops and Lists

## Webcast Recording

Here is the link to the [video][recording].  The video does have a problem with the later half, as the camera picks up Anthony's screen, but not Luke's. 
Here are links to [Luke's Code][code1] and [Anthony's Code][code2].

Today we'll be going over a couple different problems!  Anthony and Luke will each give each other a problem that the other coach hasn't prepared for, and we'll watch as they solve it in real time.

###Problem 1
Luke's problem to Anthony is from a part of [CS101](https://www.udacity.com/course/viewer#!/c-cs101/) which isn't in IPND, specifically [this problem](https://www.udacity.com/course/viewer#!/c-cs101/l-48737171/e-48299954/m-48632793):

```python
# The built-in <string>.split() procedure works
# okay, but fails to find all the words on a page
# because it only uses whitespace to split the
# string. To do better, we should also use punctuation
# marks to split the page into words.

# Define a procedure, split_string, that takes two
# inputs: the string to split and a string containing
# all of the characters considered separators. The
# procedure should return a list of strings that break
# the source string up by the characters in the
# splitlist.
```

In other words, we will be defining a procedure, called `split_string()`, which takes two arguments:

1.  The string you will be splitting
2.  A string containing every character which we will use to split up the string we will be splitting.  If you have any experience with .csv documents, these are typically called 'delimiters'.


The first things Anthony does is create the shell of a procedure, which contains the inputs:

```python
def split_string(target, separators):
```

The first thing Anthony says is he will look through the target string, and every time he finds a separator, he will split the target string from everything before and after the separator.  He then writes the below code:

```python
def split_string(target, separators):
    output = []
    for i in range(0, len(separators)):
        sep = target.find(separators[i])
        while sep != -1:
            target = target[:sep] + " " + target[sep+1:]
            sep = target.find(separators[i])
    return target.split()
```

This code works in the following way:

1.  It loops through every separator contained in the string called 'separators'
2.  For every separator, it has a while loop which goes through the target string, and replaces any instances of the target string with a space (" ")
3.  After it's done that for every instance of a given separator in the target string, it moves on to the next separator and does the same thing, until it has replaced every separator character with a space character.
4.  Finally, it splits the target string with the inbuilt Python string function 'split()', which will divide the target string along any spaces, creating a list.

From here, Anthony goes on to test his program with the tests already written from CS101:

```python
#Tests:
out = split_string("This is a test-of the,string separation-code!"," ,!-")
print out
#>>> ['This', 'is', 'a', 'test', 'of', 'the', 'string', 'separation', 'code']

out = split_string("After  the flood   ...  all the colors came out.", " .")
print out
#>>> ['After', 'the', 'flood', 'all', 'the', 'colors', 'came', 'out']

out = split_string("First Name,Last Name,Street Address,City,State,Zip Code",",")
print out
#>>>['First Name', 'Last Name', 'Street Address', 'City', 'State', 'Zip Code']
```

The commented out code below each test shows the list that *should* be generated by given inputs.

When Anthony runs the above tests on his current function, he finds that he has an infinite loop! What's causing it?  Let's take a look at his current code:


```python
def split_string(target, separators):
    output = []
    for i in range(0, len(separators)):
        sep = target.find(separators[i])
        while sep != -1:
            target = target[:sep] + " " + target[sep+1:]
            sep = target.find(separators[i])
    return target.split()
```

What happens if the current separator we are on is a space?  We will continually try to replace spaces with spaces, which will put us into a never ending loop!

Anthony fixes this like so:

```python
def split_string(target, separators):
    output = []
    for i in range(0, len(separators)):
        if separators[i] != " ":  #We add this line
            sep = target.find(separators[i])
            while sep != -1:
                target = target[:sep] + " " + target[sep+1:]
                sep = target.find(separators[i])
    return target.split()
```

Now Anthony can look at how his tests are working!

The first two test cases work perfectly:

```python
['This', 'is', 'a', 'test', 'of', 'the', 'string', 'separation', 'code']
['After', 'the', 'flood', 'all', 'the', 'colors', 'came', 'out']
```

However, the third test case was not correct:

```python
#output of test:
['First', 'Name', 'Last', 'Name', 'Street', 'Address', 'City', 'State', 'Zip', 'Code']

#desired output of test:
#['First Name', 'Last Name', 'Street Address', 'City', 'State', 'Zip Code']
```

This happens in the case where there are spaces inside of the target string, but there is no space inside of the separators string.  This is a problem for the whole method Anthony's been using to solve the problem!  

Anthony realizes this quickly, and decides to start the problem over.  After a little bit of tinkering, he realizes that the easiest way to approach the problem may be to go through the target string character by character, instead of going through each separator one at a time:

```python
def split_string(target, separators):
    output = []
    start = 0
    for i in range(0, len(target)):
        if target[i] in separators:
            output += target[start:i]
            start = i + 1
    return output
```

This gave each letter of the input string as its own entry in the output list; this isn't what we want.  This is because of a small error with `output += target[start:i]`

When you use += with a list, it expects the right side of that equation to result in a list.  Because we gave it a string, += instead treated the string as a list of characters.  This was fixed by instead using output.append(target[start:i])

The new code then was as follows:

```python
def split_string(target, separators):
    output = []
    start = 0
    for i in range(0, len(target)):
        if target[i] in separators:
            output.append(target[start:i])
            start = i + 1
    return output
```
            
This had a simple problem as well; if there were two separator characters in a row, an empty string would be added to the output list!

Finally we arrive at working code:

```python
#Anthony's Solution
def split_string(target, separators):
    output = []
    start = 0
    #Go through every character of the target string
    for i in range(0, len(target)):
        # if the current character is in separators, add 
        # everything up to this point to the output list
        if target[i] in separators:
            if i != start:
                output.append(target[start:i])
            start = i + 1

    # Then make sure not to add anything if 
    # there are two separator characters in a row
    if start != len(target):
        output.append(target[start:])
​
    return output
```

Luke then shared a solution he created early in the day, which followed the same solution pattern:

```python
def split_string(source, splitlist):
    outlist = []
    current = ""
    for character in source:
        if character in splitlist:
            if current:
                outlist.append(current)
                current = ""
        else:
            current += character
    if current:
        outlist.append(current)
    return outlist
```

###Anthony's Problem for Luke

Anthony's mom is a gardner; she works a lot with landscaping people's homes.  One thing common in landscaping is laying down bricks.  Bricks only come in certain sizes, and it would be nice to figure out exactly what bricks to buy based on the land available.  

Write a function that takes in a certain maximum number of small and large bricks which could be bought as parameters.  Each brick will be either 1 or 5 inches long, based on its size.  It will also take in total goal space to put bricks into.

Everything here will be in 1D; assume you only need to solve for a single line of bricks.  

The output will then be how many bricks of each size to buy, or, if it is impossible to fill the space, it will return False.

After some further probing, it was decided that the small brick size would always be one, the large brick size and total goal size would always be an integer.  This is necessary, because if the large brick size and total size were not divisible by the large brick size, the algorithm to find the results would necessarily be different (and more complicated).



Luke then came up with this code, which should probably be split into multiple procedures, but was kept as a single procedure for time considerations (and the sake of brevity):

```python
small_brick_size = 1
large_brick_size = 5

def make_bricks(target_len, supply_small_bricks, supply_large_bricks):
    can_make_bricks = supply_small_bricks*small_brick_size + supply_large_bricks*large_brick_size >= target_len
    if not can_make_bricks:
        return False
    len_so_far = 0
    large_bricks_to_buy = 0
    small_bricks_to_buy = 0
    while large_bricks_to_buy < supply_large_bricks and len_so_far + large_brick_size <= target_len:
        large_bricks_to_buy += 1
        len_so_far += large_brick_size
    while small_bricks_to_buy < supply_small_bricks and len_so_far + small_brick_size <= target_len:
        small_bricks_to_buy += 1
        len_so_far += small_brick_size
    if len_so_far != target_len:
        return False
    return small_bricks_to_buy, large_bricks_to_buy
```

A few test cases to check to see if it works:

```python
print make_bricks(6, 3, 3)
print make_bricks(6, 3, 5)
print make_bricks(6, 100, 100)
```

Some examples of why the code fails for why the divisibility assumptions are necessary:

```python
small_bricks_size = 2
large_brick_size = 5

print make_bricks(6, 1, 3)
```

This is technically possible, but the current code won't find the solution.  However, there was not enough time to add sufficient complexity to handle cases like this.

This problem was inspired by a classic problem for finding change (and often even the minimum number of coins) for a given monetary amount.  

Anthony also shared his solution from earlier in the day:

```python
def makebricks (small, large, goal):
    sm = 0
    lg = 0
    while goal > 0:
        if large > 0 and goal >= 5:
            lg += 1
            goal -= 5
            large -= 1
        elif small > 0:
            sm += 1
            goal -= 1
            small -= 1
        elif goal > 0:
            return "Not possible"
    return "small: " + str(sm) + " large: " + str(lg)
​
print makebricks(3, 5, 8)
print makebricks(0, 5, 8)
print makebricks(0, 5, 5)
print makebricks(20, 4, 4)
print makebricks(10, 5, 28)
```

[recording][https://plus.google.com/u/0/events/cp0l2k9i3t9sju7chvi9bespqj8?authkey=CLXExrjJ9OvFhAE]
[code1][make_bricks.py]
[code2][split_string.py]
